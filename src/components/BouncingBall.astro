---
// 旋转六边形内弹跳小球组件
---

<canvas id="hexagonCanvas"></canvas>

<style>
  #hexagonCanvas {
    display: block;
    margin: 0 auto;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 50%, #f093fb 100%);
    animation: gradientShift 10s ease infinite;
    cursor: grab;
  }

  #hexagonCanvas:active {
    cursor: grabbing;
  }

  @keyframes gradientShift {
    0%, 100% {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 50%, #f093fb 100%);
    }
    50% {
      background: linear-gradient(135deg, #4facfe 0%, #00f2fe 50%, #43e97b 100%);
    }
  }
</style>

<script>
  // 获取 Canvas 元素和上下文
  const canvas = document.getElementById('hexagonCanvas') as HTMLCanvasElement;
  const ctx = canvas.getContext('2d')!;

  // 设置 Canvas 尺寸
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;

  // 物理常量（改为可变变量）
  let GRAVITY = 0.5; // 重力加速度
  const FRICTION = 0.98; // 摩擦系数（能量损失）
  const BOUNCE_DAMPING = 0.8; // 反弹阻尼

  // 六边形参数
  const hexagonRadius = Math.min(canvas.width, canvas.height) * 0.3;
  const hexagonCenter = { x: canvas.width / 2, y: canvas.height / 2 };
  let hexagonRotation = 0;
  let rotationSpeed = 0.01; // 旋转速度（改为可变变量）

  // 小球参数
  const ball = {
    x: hexagonCenter.x,
    y: hexagonCenter.y - hexagonRadius * 0.5,
    radius: 15,
    vx: 2, // x方向速度
    vy: 0, // y方向速度
    color: '#FFD700'
  };

  // 鼠标交互状态
  let isDragging = false;
  let mousePos = { x: 0, y: 0 };

  // 粒子效果
  interface Particle {
    x: number;
    y: number;
    vx: number;
    vy: number;
    size: number;
    alpha: number;
  }

  const particles: Particle[] = [];
  const PARTICLE_COUNT = 30;

  // 初始化粒子
  for (let i = 0; i < PARTICLE_COUNT; i++) {
    particles.push({
      x: Math.random() * canvas.width,
      y: Math.random() * canvas.height,
      vx: (Math.random() - 0.5) * 0.5,
      vy: (Math.random() - 0.5) * 0.5,
      size: Math.random() * 2 + 1,
      alpha: Math.random() * 0.5 + 0.2
    });
  }

  /**
   * 更新和绘制粒子
   */
  function updateParticles(): void {
    particles.forEach(particle => {
      // 更新位置
      particle.x += particle.vx;
      particle.y += particle.vy;

      // 边界检测 - 循环
      if (particle.x < 0) particle.x = canvas.width;
      if (particle.x > canvas.width) particle.x = 0;
      if (particle.y < 0) particle.y = canvas.height;
      if (particle.y > canvas.height) particle.y = 0;

      // 绘制粒子
      ctx.beginPath();
      ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
      ctx.fillStyle = `rgba(255, 255, 255, ${particle.alpha})`;
      ctx.fill();
    });
  }

  /**
   * 获取六边形的顶点坐标（考虑旋转）
   * @returns 六边形6个顶点的坐标数组
   */
  function getHexagonVertices(): { x: number; y: number }[] {
    const vertices = [];
    for (let i = 0; i < 6; i++) {
      const angle = hexagonRotation + (Math.PI / 3) * i;
      vertices.push({
        x: hexagonCenter.x + hexagonRadius * Math.cos(angle),
        y: hexagonCenter.y + hexagonRadius * Math.sin(angle)
      });
    }
    return vertices;
  }

  /**
   * 绘制六边形
   */
  function drawHexagon(): void {
    const vertices = getHexagonVertices();

    ctx.beginPath();
    ctx.moveTo(vertices[0].x, vertices[0].y);
    for (let i = 1; i < 6; i++) {
      ctx.lineTo(vertices[i].x, vertices[i].y);
    }
    ctx.closePath();

    // 添加阴影效果
    ctx.shadowColor = 'rgba(255, 255, 255, 0.5)';
    ctx.shadowBlur = 20;
    ctx.shadowOffsetX = 0;
    ctx.shadowOffsetY = 0;

    // 绘制白色发光边框
    ctx.strokeStyle = 'rgba(255, 255, 255, 0.9)';
    ctx.lineWidth = 5;
    ctx.stroke();

    // 重置阴影
    ctx.shadowBlur = 0;

    // 绘制半透明填充
    ctx.fillStyle = 'rgba(255, 255, 255, 0.05)';
    ctx.fill();

    // 添加内部边框发光效果
    ctx.beginPath();
    ctx.moveTo(vertices[0].x, vertices[0].y);
    for (let i = 1; i < 6; i++) {
      ctx.lineTo(vertices[i].x, vertices[i].y);
    }
    ctx.closePath();
    ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
    ctx.lineWidth = 2;
    ctx.stroke();
  }

  /**
   * 绘制小球
   */
  function drawBall(): void {
    // 将 hex 颜色转换为 rgba
    function hexToRgba(hex: string, alpha: number): string {
      const r = parseInt(hex.slice(1, 3), 16);
      const g = parseInt(hex.slice(3, 5), 16);
      const b = parseInt(hex.slice(5, 7), 16);
      return `rgba(${r}, ${g}, ${b}, ${alpha})`;
    }

    // 绘制外部发光效果
    ctx.beginPath();
    ctx.arc(ball.x, ball.y, ball.radius + 8, 0, Math.PI * 2);
    const outerGlow = ctx.createRadialGradient(
      ball.x,
      ball.y,
      ball.radius,
      ball.x,
      ball.y,
      ball.radius + 8
    );
    outerGlow.addColorStop(0, hexToRgba(ball.color, 0.4));
    outerGlow.addColorStop(1, hexToRgba(ball.color, 0));
    ctx.fillStyle = outerGlow;
    ctx.fill();

    // 绘制阴影
    ctx.shadowColor = 'rgba(0, 0, 0, 0.3)';
    ctx.shadowBlur = 15;
    ctx.shadowOffsetX = 3;
    ctx.shadowOffsetY = 3;

    // 绘制主球体
    ctx.beginPath();
    ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);

    // 创建径向渐变（基于选择的颜色）
    const mainGradient = ctx.createRadialGradient(
      ball.x - ball.radius * 0.3,
      ball.y - ball.radius * 0.3,
      0,
      ball.x,
      ball.y,
      ball.radius
    );

    // 为不同的颜色创建适当的渐变效果
    // 这里使用一种通用的方法来创建高光和阴影效果
    mainGradient.addColorStop(0, hexToRgba(ball.color, 1)); // 中心高光
    mainGradient.addColorStop(0.5, ball.color); // 主颜色
    mainGradient.addColorStop(1, hexToRgba(ball.color, 0.7)); // 边缘阴影

    ctx.fillStyle = mainGradient;
    ctx.fill();

    // 重置阴影
    ctx.shadowBlur = 0;
    ctx.shadowOffsetX = 0;
    ctx.shadowOffsetY = 0;

    // 绘制边框
    ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
    ctx.lineWidth = 2.5;
    ctx.stroke();

    // 添加高光效果
    ctx.beginPath();
    ctx.arc(
      ball.x - ball.radius * 0.35,
      ball.y - ball.radius * 0.35,
      ball.radius * 0.4,
      0,
      Math.PI * 2
    );
    const highlight = ctx.createRadialGradient(
      ball.x - ball.radius * 0.35,
      ball.y - ball.radius * 0.35,
      0,
      ball.x - ball.radius * 0.35,
      ball.y - ball.radius * 0.35,
      ball.radius * 0.4
    );
    highlight.addColorStop(0, 'rgba(255, 255, 255, 0.9)');
    highlight.addColorStop(1, 'rgba(255, 255, 255, 0)');
    ctx.fillStyle = highlight;
    ctx.fill();
  }

  /**
   * 计算点到线段的距离和最近点
   * @param point 点坐标
   * @param lineStart 线段起点
   * @param lineEnd 线段终点
   * @returns 距离和最近点
   */
  function pointToLineDistance(
    point: { x: number; y: number },
    lineStart: { x: number; y: number },
    lineEnd: { x: number; y: number }
  ): { distance: number; closestPoint: { x: number; y: number }; t: number } {
    const dx = lineEnd.x - lineStart.x;
    const dy = lineEnd.y - lineStart.y;
    const lengthSquared = dx * dx + dy * dy;

    let t = ((point.x - lineStart.x) * dx + (point.y - lineStart.y) * dy) / lengthSquared;
    t = Math.max(0, Math.min(1, t));

    const closestPoint = {
      x: lineStart.x + t * dx,
      y: lineStart.y + t * dy
    };

    const distance = Math.sqrt(
      Math.pow(point.x - closestPoint.x, 2) + Math.pow(point.y - closestPoint.y, 2)
    );

    return { distance, closestPoint, t };
  }

  /**
   * 检测并处理碰撞
   */
  function handleCollisions(): void {
    const vertices = getHexagonVertices();

    // 检查每条边
    for (let i = 0; i < 6; i++) {
      const v1 = vertices[i];
      const v2 = vertices[(i + 1) % 6];

      const { distance, closestPoint } = pointToLineDistance(ball, v1, v2);

      // 如果球与边碰撞
      if (distance < ball.radius) {
        // 计算法线方向（从碰撞点指向球心）
        const normalX = ball.x - closestPoint.x;
        const normalY = ball.y - closestPoint.y;
        const normalLength = Math.sqrt(normalX * normalX + normalY * normalY);

        if (normalLength === 0) continue;

        const nx = normalX / normalLength;
        const ny = normalY / normalLength;

        // 将球移出碰撞区域
        const overlap = ball.radius - distance;
        ball.x += nx * overlap;
        ball.y += ny * overlap;

        // 计算速度在法线方向的分量
        const dotProduct = ball.vx * nx + ball.vy * ny;

        // 只有当球正在向墙壁移动时才反弹
        if (dotProduct < 0) {
          // 反弹：反射速度向量
          ball.vx -= 2 * dotProduct * nx;
          ball.vy -= 2 * dotProduct * ny;

          // 应用阻尼和摩擦
          ball.vx *= BOUNCE_DAMPING;
          ball.vy *= BOUNCE_DAMPING;
        }
      }
    }
  }

  /**
   * 更新物理状态
   */
  function updatePhysics(): void {
    if (isDragging) {
      // 拖拽时，球跟随鼠标，速度归零
      ball.x = mousePos.x;
      ball.y = mousePos.y;
      ball.vx = 0;
      ball.vy = 0;
    } else {
      // 应用重力
      ball.vy += GRAVITY;

      // 应用摩擦
      ball.vx *= FRICTION;
      ball.vy *= FRICTION;

      // 更新位置
      ball.x += ball.vx;
      ball.y += ball.vy;

      // 检测碰撞
      handleCollisions();
    }
  }

  /**
   * 动画循环
   */
  function animate(): void {
    // 清空画布
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // 更新六边形旋转
    hexagonRotation += rotationSpeed;

    // 绘制粒子效果
    updateParticles();

    // 绘制
    drawHexagon();
    updatePhysics();
    drawBall();

    // 继续动画
    requestAnimationFrame(animate);
  }

  /**
   * 检查点是否在球内
   */
  function isPointInBall(x: number, y: number): boolean {
    const dx = x - ball.x;
    const dy = y - ball.y;
    return Math.sqrt(dx * dx + dy * dy) <= ball.radius;
  }

  // 鼠标事件处理
  canvas.addEventListener('mousedown', (e) => {
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;

    if (isPointInBall(x, y)) {
      isDragging = true;
      mousePos = { x, y };
    }
  });

  canvas.addEventListener('mousemove', (e) => {
    if (isDragging) {
      const rect = canvas.getBoundingClientRect();
      mousePos = {
        x: e.clientX - rect.left,
        y: e.clientY - rect.top
      };
    }
  });

  canvas.addEventListener('mouseup', () => {
    isDragging = false;
  });

  canvas.addEventListener('mouseleave', () => {
    isDragging = false;
  });

  // 触摸事件支持
  canvas.addEventListener('touchstart', (e) => {
    e.preventDefault();
    const rect = canvas.getBoundingClientRect();
    const touch = e.touches[0];
    const x = touch.clientX - rect.left;
    const y = touch.clientY - rect.top;

    if (isPointInBall(x, y)) {
      isDragging = true;
      mousePos = { x, y };
    }
  });

  canvas.addEventListener('touchmove', (e) => {
    e.preventDefault();
    if (isDragging) {
      const rect = canvas.getBoundingClientRect();
      const touch = e.touches[0];
      mousePos = {
        x: touch.clientX - rect.left,
        y: touch.clientY - rect.top
      };
    }
  });

  canvas.addEventListener('touchend', () => {
    isDragging = false;
  });

  // 窗口大小调整处理
  window.addEventListener('resize', () => {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    hexagonCenter.x = canvas.width / 2;
    hexagonCenter.y = canvas.height / 2;
    
    // 重新初始化粒子位置
    particles.forEach(particle => {
      if (particle.x > canvas.width) particle.x = Math.random() * canvas.width;
      if (particle.y > canvas.height) particle.y = Math.random() * canvas.height;
    });
  });

  // 添加事件监听器，接收来自控制面板的参数更新
  window.addEventListener('updateGravity', (e) => {
    GRAVITY = e.detail.gravity;
  });

  window.addEventListener('updateRotationSpeed', (e) => {
    rotationSpeed = e.detail.rotationSpeed;
  });

  window.addEventListener('updateBallColor', (e) => {
    ball.color = e.detail.color;
  });

  // 启动动画
  animate();
</script>
